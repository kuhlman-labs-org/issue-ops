name: Create Repository on Approval

on:
  issue_comment:
    types: [created]

jobs:
  create_repo:
    runs-on: ubuntu-latest
    steps:
      - name: Check for newrepo Label
        id: label-check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ISSUE_OPS_TOKEN }}
          script: |
            const issueNumber = context.issue.number;
            // Fetch the latest issue data.
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
            });
            // Normalize labels (they may be objects or strings)
            const labels = issue.labels.map(label => typeof label === 'string' ? label : label.name);
            console.log("Fetched labels: " + JSON.stringify(labels));      
            // Check for the label in a case-insensitive way.
            const hasNewRepoLabel = labels.some(l => l.toLowerCase() === "newrepo");
            if (!hasNewRepoLabel) {
              core.info("Issue does not have the 'newrepo' label.");
            }
            // Explicitly set the output value.
            core.setOutput("runWorkflow", hasNewRepoLabel ? "true" : "false");
            
      - name: Exit if Not a Repository Request
        if: steps.label-check.outputs.runWorkflow == 'false'
        run: echo "Not a repository request; skipping."

      - name: Validate Approver
        id: validate-approver
        if: steps.label-check.outputs.runWorkflow == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ISSUE_OPS_TOKEN }}
          script: |
            // Only proceed if the comment contains the '/approve' command.
            if (!context.payload.comment.body.includes("/approve")) {
              core.info("No '/approve' command found in the comment. Exiting.");
              core.setOutput("valid", "false");
              return;
            }
            // Identify the user who posted the /approve comment.
            const approver = context.payload.comment.user.login;
            const org = context.repo.owner;
            // Specify the team slug for issue‑ops.
            const team_slug = "issue-ops";
            let isMember = false;
            try {
              // Check if the approver is an active member of the issue‑ops team.
              const membership = await github.rest.teams.getMembershipForUserInOrg({
                org: org,
                team_slug: team_slug,
                username: approver
              });
              console.log(`Membership for @${approver}: ${JSON.stringify(membership.data)}`);
              if (membership.data && membership.data.state === 'active') {
                isMember = true;
              }
            } catch (error) {
              console.log(`Error checking membership for @${approver}: ${error}`);
            }
            if (!isMember) {
              throw new Error(`User @${approver} is not a member of the '${team_slug}' team and is not authorized to approve repository creation.`);
            }
            // Explicitly set the output to signal a valid approver.
            core.setOutput("valid", "true");

      - name: Create Repository and Configure Access
        if: steps.validate-approver.outputs.valid == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ISSUE_OPS_TOKEN }}
          script: |
            // The issue body comes from the GitHub issue form.
            const issueBody = context.payload.issue.body;

            // Helper functions to extract values from markdown fields.
            function extractValue(fieldLabel) {
              const regex = new RegExp(`\\*\\*${fieldLabel}:\\*\\*\\s*(.+)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : null;
            }
            function extractMultilineValue(fieldLabel) {
              const regex = new RegExp(`\\*\\*${fieldLabel}:\\*\\*\\s*([\\s\\S]+)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : null;
            }

            // Extract values from the issue form.
            const repoOwner         = extractValue("Repository owner");
            const repoName          = extractValue("Repository name");
            const repoDesc          = extractValue("Repository description") || "";
            const repoVisibilityRaw = extractValue("Repository visibility");
            const repoAccessRaw     = extractMultilineValue("Repository access");

            if (!repoOwner || !repoName || !repoVisibilityRaw || !repoAccessRaw) {
              throw new Error("Missing required field(s). Ensure Repository owner, name, visibility, and access are provided.");
            }

            // Determine repository visibility.
            const visibility = repoVisibilityRaw.toLowerCase() === "internal" ? "internal" : "private";
            console.log(`Creating repository ${repoOwner}/${repoName} with ${visibility} visibility.`);

            // Create the repository in the specified organization.
            const createRepoParams = {
              org: repoOwner,
              name: repoName,
              description: repoDesc,
              auto_init: true,
              visibility: visibility,
            };
            const repoResponse = await github.rest.repos.createInOrg(createRepoParams);
            console.log(`Repository created: ${repoResponse.data.full_name}`);

            // Process the "Repository access" field.
            let accessEntries = [];
            if (repoAccessRaw.includes('\n')) {
              accessEntries = repoAccessRaw.split(/\r?\n/).map(line => line.trim()).filter(line => line);
            } else {
              const tokens = repoAccessRaw.split(',').map(token => token.trim()).filter(token => token);
              for (let i = 0; i < tokens.length; i += 2) {
                accessEntries.push(`${tokens[i]},${tokens[i+1] || ''}`);
              }
            }

            async function addUserCollaborator(username, permission) {
              console.log(`Adding collaborator ${username} with permission ${permission}`);
              await github.rest.repos.addCollaborator({
                owner: repoOwner,
                repo: repoName,
                username: username,
                permission: permission, // Valid options: pull, triage, push, maintain, admin
              });
            }
            async function addTeamAccess(teamSlug, permission) {
              console.log(`Granting team ${teamSlug} permission ${permission}`);
              await github.rest.teams.addOrUpdateRepoPermissionsInOrg({
                org: repoOwner,
                team_slug: teamSlug,
                owner: repoOwner,
                repo: repoName,
                permission: permission,
              });
            }

            for (const entry of accessEntries) {
              const parts = entry.split(',').map(part => part.trim());
              if (parts.length < 2) {
                console.log(`Skipping invalid access entry: ${entry}`);
                continue;
              }
              const entity = parts[0];
              const permission = parts[1].toLowerCase();
              if (entity.startsWith('@') && entity.includes('/')) {
                const teamSlug = entity.split('/')[1].toLowerCase();
                await addTeamAccess(teamSlug, permission);
              } else {
                const username = entity.startsWith('@') ? entity.slice(1) : entity;
                await addUserCollaborator(username, permission);
              }
            }

            // Ensure the issue creator gets admin access.
            const issueCreator = context.payload.issue.user.login;
            console.log(`Adding issue creator @${issueCreator} as admin collaborator.`);
            await github.rest.repos.addCollaborator({
              owner: repoOwner,
              repo: repoName,
              username: issueCreator,
              permission: "admin",
            });

            // Post a comment to notify the issue creator.
            const commentBody = `@${issueCreator} Your repository **${repoName}** has been successfully created in **${repoOwner}** and you have been granted admin access.`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody,
            });
            console.log("Repository setup complete.");

name: Create Repository on Approval

on:
  issue_comment:
    types: [created]

jobs:
  create_repo:
    runs-on: ubuntu-latest
    steps:
      - name: Check for newrepo label
        id: label-check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ISSUE_OPS_TOKEN }}
          script: |
            const labels = context.payload.issue.labels.map(label => label.name);
            if (!labels.includes("newrepo")) {
              core.info("Issue does not have the newrepo label. Exiting.");
              return { runWorkflow: false };
            }
            return { runWorkflow: true };

      - name: Exit if not a repository request
        if: steps.label-check.outputs.runWorkflow == 'false'
        run: echo "Not a repository request; skipping."

      - name: Validate Approver and Notify Issue‑Ops Team
        id: validate-approver
        if: steps.label-check.outputs.runWorkflow == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ISSUE_OPS_TOKEN }}
          script: |
            // Identify the user who posted the /approved comment.
            const approver = context.payload.comment.user.login;
            const org = context.repo.owner;
            // Update this team slug to match your issue‑ops team.
            const team_slug = "issue-ops"; 
            let isMember = false;
            try {
              // Check membership of the approver in the issue‑ops team.
              const membership = await github.rest.teams.getMembershipForUserInOrg({
                org: org,
                team_slug: team_slug,
                username: approver
              });
              console.log(`Membership for @${approver}: ${JSON.stringify(membership.data)}`);
              if (membership.data && membership.data.state === 'active') {
                isMember = true;
              }
            } catch (error) {
              console.log(`Error checking membership for @${approver}: ${error}`);
            }
            if (!isMember) {
              throw new Error(`User @${approver} is not a member of the ${team_slug} team and is not authorized to approve repository creation.`);
            }
            // Notify the issue‑ops team by mentioning them in a comment.
            // The team mention syntax is @org/team_slug.
            const teamMention = `@${org}/${team_slug}`;
            const notifyComment = `Repository creation approval received from @${approver}. ${teamMention} team, please review this request.`;
            await github.rest.issues.createComment({
              owner: org,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: notifyComment
            });
            return { valid: true };

      - name: Create Repository and Configure Access
        if: steps.label-check.outputs.runWorkflow == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.ISSUE_OPS_TOKEN }}
          script: |
            // Extract the issue body generated by the GitHub issue form.
            const issueBody = context.payload.issue.body;

            // Helper functions to extract single-line and multi-line values.
            function extractValue(fieldLabel) {
              const regex = new RegExp(`\\*\\*${fieldLabel}:\\*\\*\\s*(.+)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : null;
            }
            function extractMultilineValue(fieldLabel) {
              const regex = new RegExp(`\\*\\*${fieldLabel}:\\*\\*\\s*([\\s\\S]+)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : null;
            }

            // Extract form values.
            const repoOwner         = extractValue("Repository owner");
            const repoName          = extractValue("Repository name");
            const repoDesc          = extractValue("Repository description") || "";
            const repoVisibilityRaw = extractValue("Repository visibility");
            const repoAccessRaw     = extractMultilineValue("Repository access");

            if (!repoOwner || !repoName || !repoVisibilityRaw || !repoAccessRaw) {
              throw new Error("Missing required field(s). Ensure Repository owner, name, visibility, and access are provided.");
            }

            // Determine repository visibility.
            // (Assumes form options are "Internal" or "Private".)
            const visibility = repoVisibilityRaw.toLowerCase() === "internal" ? "internal" : "private";
            console.log(`Creating repository ${repoOwner}/${repoName} with ${visibility} visibility.`);

            // Create the repository in the specified organization.
            const createRepoParams = {
              org: repoOwner,
              name: repoName,
              description: repoDesc,
              auto_init: true,
              visibility: visibility,
            };
            const repoResponse = await github.rest.repos.createInOrg(createRepoParams);
            console.log(`Repository created: ${repoResponse.data.full_name}`);

            // --- Process Repository Access ---
            // Expecting the "Repository access" field to be comma- or newline-delimited.
            // Each entry should be in one of these formats:
            //   For teams: "@org/teamslug,permission"
            //   For users: "username,permission" or "@username,permission"
            let accessEntries = [];
            if (repoAccessRaw.includes('\n')) {
              accessEntries = repoAccessRaw.split(/\r?\n/).map(line => line.trim()).filter(line => line);
            } else {
              const tokens = repoAccessRaw.split(',').map(token => token.trim()).filter(token => token);
              for (let i = 0; i < tokens.length; i += 2) {
                accessEntries.push(`${tokens[i]},${tokens[i+1] || ''}`);
              }
            }

            // Functions to grant access.
            async function addUserCollaborator(username, permission) {
              console.log(`Adding collaborator ${username} with permission ${permission}`);
              await github.rest.repos.addCollaborator({
                owner: repoOwner,
                repo: repoName,
                username: username,
                permission: permission, // Valid values: pull, triage, push, maintain, admin
              });
            }
            async function addTeamAccess(teamSlug, permission) {
              console.log(`Granting team ${teamSlug} permission ${permission}`);
              await github.rest.teams.addOrUpdateRepoPermissionsInOrg({
                org: repoOwner,
                team_slug: teamSlug,
                owner: repoOwner,
                repo: repoName,
                permission: permission,
              });
            }

            // Process each access entry.
            for (const entry of accessEntries) {
              const parts = entry.split(',').map(part => part.trim());
              if (parts.length < 2) {
                console.log(`Skipping invalid access entry: ${entry}`);
                continue;
              }
              const entity = parts[0];
              const permission = parts[1].toLowerCase();
              if (entity.startsWith('@') && entity.includes('/')) {
                // For team entries, extract the team slug.
                const teamSlug = entity.split('/')[1].toLowerCase();
                await addTeamAccess(teamSlug, permission);
              } else {
                // For user entries.
                const username = entity.startsWith('@') ? entity.slice(1) : entity;
                await addUserCollaborator(username, permission);
              }
            }

            // --- Ensure the Issue Creator Gets Admin Access ---
            const issueCreator = context.payload.issue.user.login;
            console.log(`Adding issue creator @${issueCreator} as admin collaborator.`);
            await github.rest.repos.addCollaborator({
              owner: repoOwner,
              repo: repoName,
              username: issueCreator,
              permission: "admin",
            });

            // --- Post a Comment on the Issue ---
            const commentBody = `@${issueCreator} Your repository **${repoName}** has been successfully created in **${repoOwner}**. You have been granted admin access.`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody,
            });
            console.log("Repository setup complete.");

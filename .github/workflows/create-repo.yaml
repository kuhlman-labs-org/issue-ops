name: Create Repository on Approval

on:
  issue_comment:
    types: [created]

jobs:
  create_repo:
    runs-on: ubuntu-latest
    steps:
      - name: Check for newrepo label
        id: label-check
        uses: actions/github-script@v6
        with:
          script: |
            const labels = context.payload.issue.labels.map(label => label.name);
            if (!labels.includes("newrepo")) {
              core.info("Issue does not have the newrepo label. Exiting.");
              return { runWorkflow: false };
            }
            return { runWorkflow: true };
      
      - name: Exit if not a repository request
        if: steps.label-check.outputs.runWorkflow == 'false'
        run: echo "Not a repository request; skipping."

      - name: Create Repository and Configure Access
        if: steps.label-check.outputs.runWorkflow == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            // Extract the issue body generated by the GitHub issue form.
            const issueBody = context.payload.issue.body;

            // Helper functions to extract single-line and multi-line values.
            function extractValue(fieldLabel) {
              const regex = new RegExp(`\\*\\*${fieldLabel}:\\*\\*\\s*(.+)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : null;
            }
            function extractMultilineValue(fieldLabel) {
              const regex = new RegExp(`\\*\\*${fieldLabel}:\\*\\*\\s*([\\s\\S]+)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : null;
            }

            // Extract values from the form.
            const repoOwner         = extractValue("Repository owner");
            const repoName          = extractValue("Repository name");
            const repoDesc          = extractValue("Repository description") || "";
            const repoVisibilityRaw = extractValue("Repository visibility");
            const repoAccessRaw     = extractMultilineValue("Repository access");

            if (!repoOwner || !repoName || !repoVisibilityRaw || !repoAccessRaw) {
              throw new Error("Missing required field(s). Ensure Repository owner, name, visibility, and access are provided.");
            }

            // Determine repository visibility.
            // Our form options are "Internal" and "Private".
            const visibility = repoVisibilityRaw.toLowerCase() === "internal" ? "internal" : "private";
            console.log(`Creating repository ${repoOwner}/${repoName} with ${visibility} visibility.`);

            // Create the repository in the selected organization.
            const createRepoParams = {
              org: repoOwner,
              name: repoName,
              description: repoDesc,
              auto_init: true,
              visibility: visibility,
            };
            const repoResponse = await github.rest.repos.createInOrg(createRepoParams);
            console.log(`Repository created: ${repoResponse.data.full_name}`);

            // --- Process Repository Access ---
            // The "Repository access" field is expected to be a comma- or newline-separated list.
            // Each entry should be in the form:
            //   For teams: "@org/teamslug,permission"
            //   For users: "username,permission" or "@username,permission"
            let accessEntries = [];
            if (repoAccessRaw.includes('\n')) {
              accessEntries = repoAccessRaw.split(/\r?\n/).map(line => line.trim()).filter(line => line);
            } else {
              const tokens = repoAccessRaw.split(',').map(token => token.trim()).filter(token => token);
              for (let i = 0; i < tokens.length; i += 2) {
                accessEntries.push(`${tokens[i]},${tokens[i+1] || ''}`);
              }
            }

            // Functions to grant access.
            async function addUserCollaborator(username, permission) {
              console.log(`Adding collaborator ${username} with permission ${permission}`);
              await github.rest.repos.addCollaborator({
                owner: repoOwner,
                repo: repoName,
                username: username,
                permission: permission, // Valid values: pull, triage, push, maintain, admin
              });
            }
            async function addTeamAccess(teamSlug, permission) {
              console.log(`Granting team ${teamSlug} permission ${permission}`);
              await github.rest.teams.addOrUpdateRepoPermissionsInOrg({
                org: repoOwner,
                team_slug: teamSlug,
                owner: repoOwner,
                repo: repoName,
                permission: permission,
              });
            }

            // Process each access entry.
            for (const entry of accessEntries) {
              const parts = entry.split(',').map(part => part.trim());
              if (parts.length < 2) {
                console.log(`Skipping invalid access entry: ${entry}`);
                continue;
              }
              const entity = parts[0];
              const permission = parts[1].toLowerCase();

              // If the entity starts with "@" and contains a "/", assume it's a team.
              if (entity.startsWith('@') && entity.includes('/')) {
                // Example: "@org/teamslug" â†’ extract teamSlug as "teamslug"
                const teamSlug = entity.split('/')[1].toLowerCase();
                await addTeamAccess(teamSlug, permission);
              } else {
                // Otherwise, treat it as a username.
                const username = entity.startsWith('@') ? entity.slice(1) : entity;
                await addUserCollaborator(username, permission);
              }
            }

            // --- Ensure Issue Creator Has Admin Access ---
            const issueCreator = context.payload.issue.user.login;
            console.log(`Adding issue creator ${issueCreator} as an admin collaborator.`);
            await github.rest.repos.addCollaborator({
              owner: repoOwner,
              repo: repoName,
              username: issueCreator,
              permission: "admin",
            });

            // --- Post a Comment on the Issue ---
            const commentBody = `@${issueCreator} Your repository **${repoName}** has been successfully created in **${repoOwner}**. You have been granted admin access.`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody,
            });
            console.log("Repository setup complete and issue commented.");
